import os
import json
import random
import feedparser
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from google import genai
from dotenv import load_dotenv

# --- CONFIGURATION ---
load_dotenv()
app = FastAPI(title="FinNews AI Engine")

# CORS for frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["GET"],
    allow_headers=["*"],
)

# --- DATA MODELS ---
class ColorBlock(BaseModel):
    texto: str
    color: Literal["ROJO", "VERDE"]

class ImpactBlock(BaseModel):
    nivel: Literal["ALTO", "MEDIO", "BAJO"]
    color: Literal["ROJO", "VERDE"]

class AnalysisBlocks(BaseModel):
    que_paso: ColorBlock
    por_que_importa: ColorBlock
    como_afecta_etfs_o_acciones: ColorBlock
    que_hacer: ColorBlock

class NewsResponse(BaseModel):
    titulo: str
    link_original: str
    impacto_general: ImpactBlock
    bloques: AnalysisBlocks

# --- AI SERVICE ---
def analyze_single_news(title: str, summary: str, link: str) -> Optional[NewsResponse]:
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY not set")
    
    client = genai.Client(api_key=api_key)

    prompt = f"""
    Actúa como un motor de análisis financiero estricto. Analiza esta noticia:
    Titulo: {title}
    Resumen: {summary}

    Tu tarea es generar un JSON válido con la siguiente estructura exacta.
    NO añadas markdown, ni ```json, solo el objeto JSON crudo.

    REGLAS DE COLOR:
    - ROJO: Si hay riesgo, volatilidad, impacto negativo o relevancia crítica.
    - VERDE: Si es positivo, neutral, sin impacto material o "ruido".

    ESTRUCTURA JSON REQUERIDA:
    {{
      "titulo": "Titulo breve (máx 8 palabras)",
      "impacto_general": {{
        "nivel": "ALTO | MEDIO | BAJO",
        "color": "ROJO | VERDE"
      }},
      "bloques": {{
        "que_paso": {{
          "texto": "Descripción factual objetiva (máx 3 líneas).",
          "color": "ROJO | VERDE"
        }},
        "por_que_importa": {{
          "texto": "Relevancia macro/sectorial sin opinión.",
          "color": "ROJO | VERDE"
        }},
        "como_afecta_etfs_o_acciones": {{
          "texto": "Tickers o sectores específicos afectados.",
          "color": "ROJO | VERDE"
        }},
        "que_hacer": {{
          "texto": "Acción: Vigilar, Mantener, Esperar (Sin consejo financiero).",
          "color": "ROJO | VERDE"
        }}
      }}
    }}
    """

    try:
        response = client.models.generate_content(
            model="gemini-2.0-flash-lite",
            contents=prompt,
            config=genai.types.GenerateContentConfig(
                response_mime_type="application/json"
            )
        )
        
        data = json.loads(response.text)
        # Inject original link as it's not generated by AI
        data["link_original"] = link
        return NewsResponse(**data)
    except Exception as e:
        print(f"AI Error: {e}")
        return None

# --- RSS SERVICE ---
RSS_SOURCES = [
    "[https://es.investing.com/rss/news.rss](https://es.investing.com/rss/news.rss)",
    "[https://feeds.content.dowjones.io/public/rss/mw_topstories](https://feeds.content.dowjones.io/public/rss/mw_topstories)",
    "[https://cointelegraph.com/rss](https://cointelegraph.com/rss)"
]

def get_raw_news_item(index: int):
    # Flatten all feeds into one list (simplified for demo)
    all_entries = []
    for source in RSS_SOURCES:
        try:
            feed = feedparser.parse(source)
            all_entries.extend(feed.entries)
        except:
            continue
    
    # Sort by published date if available, else random shuffle to avoid stale top
    all_entries.sort(key=lambda x: x.get('published_parsed', 0), reverse=True)
    
    if not all_entries:
        return None
    
    # Modulo to loop infinitely through available news
    safe_index = index % len(all_entries)
    return all_entries[safe_index]

# --- ENDPOINT ---
@app.get("/news/next", response_model=NewsResponse)
def get_next_news(index: int = Query(0, description="Pagination index for infinite scroll")):
    """
    Fetches a single news item based on the index, analyzes it with AI, 
    and returns the structured JSON for the 2x2 grid UI.
    """
    raw_item = get_raw_news_item(index)
    
    if not raw_item:
        raise HTTPException(status_code=503, detail="No news sources available")

    # Extract text content
    summary_text = getattr(raw_item, "summary", getattr(raw_item, "description", ""))
    
    # Process with AI
    analyzed_news = analyze_single_news(
        title=raw_item.title, 
        summary=summary_text, 
        link=raw_item.link
    )

    if not analyzed_news:
        raise HTTPException(status_code=500, detail="Error analyzing news content")

    return analyzed_news

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
